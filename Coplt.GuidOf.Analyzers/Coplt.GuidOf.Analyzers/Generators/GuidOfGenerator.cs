using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Coplt.Analyzers.Utilities;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Coplt.Analyzers.Generators;

[Generator]
public class GuidOfGenerator : IIncrementalGenerator
{
    private static INamedTypeSymbol? FindSymbol(ISymbol? symbol) => symbol is IMethodSymbol
    {
        IsGenericMethod: true,
        TypeArguments: [INamedTypeSymbol target],
        Name: "Get" or "AsOf",
        ContainingType:
        {
            Name: "GuidType",
            ContainingNamespace:
            {
                Name: "GuidOfs",
                ContainingNamespace:
                {
                    Name: "Coplt",
                    ContainingNamespace.IsGlobalNamespace: true,
                }
            }
        },
    }
        ? target
        : null;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var sources = context.SyntaxProvider.CreateSyntaxProvider(
                static (node, _) => node is InvocationExpressionSyntax,
                static (ctx, cancel) =>
                {
                    var invocation = (InvocationExpressionSyntax)ctx.Node;
                    var symbol = ctx.SemanticModel.GetSymbolInfo(invocation, cancel);
                    var target = FindSymbol(symbol.Symbol) ??
                                 symbol.CandidateSymbols.Select(FindSymbol).FirstOrDefault(static s => s != null);
                    if (target is null) return default;

                    var attr = target.GetAttributes().FirstOrDefault(static a => a.AttributeClass is
                    {
                        Name: nameof(GuidAttribute),
                        ContainingNamespace:
                        {
                            Name: nameof(System.Runtime.InteropServices),
                            ContainingNamespace:
                            {
                                Name: nameof(System.Runtime),
                                ContainingNamespace:
                                {
                                    Name: nameof(System),
                                    ContainingNamespace.IsGlobalNamespace: true,
                                }
                            }
                        }
                    });

                    var guid = attr is { ConstructorArguments: [{ Value: string s }] }
                        ? Guid.TryParse(s, out var r) ? r : Guid.Empty
                        : Guid.Empty;

                    var generics = target.GetGenerics(true);
                    var wheres = target.GetWheres();

                    return (target: target.ToDisplayString(), guid, generics, wheres);
                })
            .Where(static a => a.target is not null)
            .Collect()
            .SelectMany(static (a, _) => a
                .GroupBy(static a => a.target)
                .Select(static a => a.First())
            );

        context.RegisterSourceOutput(sources, static (ctx, input) =>
        {
            var (target, guid, generics, wheres) = input;
            var code = $@"// <auto-generated/>

#nullable disable

using System;
using System.Runtime.CompilerServices;

namespace Coplt.GuidOfs
{{

internal static partial class GuidTypeStaticGenerated
{{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Guid Get{generics}(this GuidType<{target}> type){wheres} => new Guid({guid.ToString("X").Replace("{", "").Replace("}", "")});

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GuidOf<{target}> AsOf{generics}(this GuidType<{target}> type){wheres} => new GuidOf<{target}>(type.Get());
}}

}} // namespace Coplt.GuidOf
";
            var sourceText = SourceText.From(code, Encoding.UTF8);
            var sourceFileName = $"{target.Replace('<', '[').Replace('>', ']')}.guid.of.g.cs";
            ctx.AddSource(sourceFileName, sourceText);
        });
    }
}
